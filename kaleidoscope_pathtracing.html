<!doctype html>
<notebook theme="air">
  <title>three.js kaleidoscope playground</title>
  <script id="1" type="text/markdown">
    # three.js kaleidoscope playground
    a realistic mirror-based kaleidoscope based on Leif Gehrmann’s [kaleidoscope-threejs-path-tracing](https://github.com/leifgehrmann/kaleidoscope-threejs-path-tracing)

    <div id="top" />
    ${nav("top")}
  </script>
  <script id="49" type="text/html">
    <div style="display: flex; max-width: 100%;" id="form">
      <div>${shapesForm} ${materialForm}</div>
      <div>
        ${kaleidoForm}
        <br />
        ${renderingForm}
      </div>
    </div>
    <div>${advancedForm}</div>
  </script>
  <script id="6" type="text/x-typescript">
    const container = display(html`
    <div style="position: relative;">
      <div id="canvases" style="display: flex;">
        <canvas id="plain"></canvas>
        <canvas id="kaleido"></canvas>
      </div>
      <div id="samples-overlay" style="position: absolute; top: 0; left: 50%;"></div>
      <small>Drag to rotate, scroll to zoom, right click to pan</small>
    </div>`);
  </script>
  <script id="89" type="text/markdown">
    ### Scene generation
    ${nav("scene-generation")}
  </script>
  <script id="17" type="text/x-typescript">
    interface Shape {
      geometry: {
        Class: typeof SHAPE_MAP[keyof SHAPE_MAP];
        args: number[];
      };
      positon: [number, number, number];
      rotation: [number, number, number];
      wireframe: boolean;
      color: string;
    }

    function generateShapes(config: ShapeConfig): Shape[] {
      const size = d3.randomInt(config.size[0], config.size[1]);
      const positionScale = d3.randomInt(-config.boundary / 2, config.boundary / 2);
      const rotationScale = d3.randomInt(0, Math.PI * 2);
      const geometryScale = d3.scaleQuantize(config.types);
      const colorScale = getScaleForScheme(config.color);
      const wireframeScale = d3.scaleQuantize([true, false]);
      const random = d3.randomUniform();

      const shapeArray: (keyof SHAPE_MAP) = useShapeDistribution
        ? d3.shuffle(shapeDistribution.flatMap((d) => Array.from({length: config.count * (d.value / 100)}, () => d.label)))
        : Array.from({length: config.count}, () => geometryScale(random()));

      return shapeArray.map((shapeName) => {
        const wireframe = config.wireframe === "all" ? true :
                          config.wireframe === "none" ? false :
                          wireframeScale(random());
        const color = colorScale(random());

        const geometryClass = SHAPE_MAP[shapeName];
        const geometryArgs = (() => {
          switch (geometryClass) {
            case THREE.BoxGeometry:
              return [size(), size(), size()];
            case THREE.CylinderGeometry:
              const end = size();
              return [end, end, size()];
            case THREE.SphereGeometry: {
              const diameter = size();
              if (wireframe) {
                // variation on segment count
                const segments = d3.max([8, d3.min([diameter * 4, 20])]);
                const v = d3.randomLogNormal(0, diameter / 3);
                return [diameter, segments - v(), segments - v()];
              } else {
                return [diameter, 20, 20];
              }
            }
            case THREE.TorusGeometry: {
              const diameter = size();
              const hole = d3.randomUniform(0.2, 0.8);
              if (wireframe) {
                // variation on segment count
                const segments = d3.max([8, d3.min([diameter * 4, 20])]);
                const v = d3.randomLogNormal(0, diameter / 3);
                return [diameter, diameter * hole(), segments - v(), (segments - v()) * 4];
              } else {
                return [diameter, diameter * hole(), 20, 80];
              }
            }
            case THREE.IcosahedronGeometry:
            case THREE.TetrahedronGeometry:
            case THREE.OctahedronGeometry:
              return [size(), 0];
            default:
              return [];
          }
        })();

        const position = Array.from({length: 3}, positionScale);
        const rotation = Array.from({length: 3}, rotationScale);

        return {
          geometry: {
            Class: geometryClass,
            args: geometryArgs,
          },
          position,
          rotation,
          wireframe,
          color,
        };
      });
    };
  </script>
  <script id="114" type="text/x-typescript" pinned="">
    refresh;

    const shapes = generateShapes({count, boundary, size, types, wireframe, color: materialColor});
  </script>
  <script id="66" type="text/x-typescript" pinned="">
    const MaterialClass = MATERIAL_MAP[material];

    function getMaterialArgs(shape: Shape) {
      const {wireframe, color} = shape;
      switch (material) {
        case 'Phong':
          return {wireframe, color, emissive: 0x000000, specular: background, shininess: 500};
        case 'Lambert':
          return {wireframe, color};
        case 'Normal':
          return {uniforms: {}, fragmentShader: normalFragmentShader, vertexShader};
        default:
          return {wireframe};
      }
    }
  </script>
  <script id="13" type="text/x-typescript" pinned="">
    function createShapeGroup(layer: number) {
      const shapeGroup = new THREE.Group();
      shapeGroup.name = "ShapeGroup";
      shapeGroup.layers.enableAll()//.set(layer);

      for (const shape of shapes) {
        const geometry = new shape.geometry.Class(...shape.geometry.args);
        const shapeMaterial = new MaterialClass(getMaterialArgs(shape));
        const mesh = new THREE.Mesh(geometry, shapeMaterial);
        mesh.position.fromArray(shape.position);
        mesh.rotation.fromArray(shape.rotation);
        mesh.layers.enableAll()//.set(layer);
        shapeGroup.add(mesh);
      }

      const axesHelper = new THREE.AxesHelper(boundary);
      axesHelper.layers.enableAll()//.set(layer);
      shapeGroup.add(axesHelper);

      return shapeGroup;
    }

    const shapeGroup = createShapeGroup(PLAIN_LAYER);
    scene.add(shapeGroup);

    const kaleidoShapeGroup = createShapeGroup(KALEIDO_LAYER);
    // kaleidoShapeGroup.up.set(0, 0, 1);
    scene.add(kaleidoShapeGroup);

    pathTracer.setScene(scene, kaleidoCamera);

    invalidation.then(() => {
      shapeGroup.removeFromParent();
      shapeGroup.clear();
      kaleidoShapeGroup.removeFromParent();
      kaleidoShapeGroup.clear();
    });
  </script>
  <script id="98" type="text/x-typescript" pinned="">
    // const lensMaterial = new THREE.MeshPhysicalMaterial({
    //   map: targetTexture.texture,
    //   transparent: true,
    //   opacity: 1,
    //   transmission: 0, // 1
    //   roughness: 1,
    //   metalness: 0,
    // });
    // const lensGeometry = new THREE.BoxGeometry(4, 0.01, 4);
    // const lens = new THREE.Mesh(lensGeometry, lensMaterial);
    // lens.rotateX(-Math.PI / 2);
    // lens.rotateZ(-Math.PI);

    // kaleidoScene.add(lens);

    // invalidation.then(() => {
    //   lens.removeFromParent();
    // });
  </script>
  <script id="97" type="text/x-typescript" pinned="">
    const mirrorGroup = new THREE.Group();
    mirrorGroup.name = "MirrorGroup";
    mirrorGroup.layers.set(KALEIDO_LAYER);

    for (let i = 0; i < sides; i++) {
      const panel = new THREE.Mesh(
        new THREE.BoxGeometry(boundary, 0.02, length),
        new THREE.MeshStandardMaterial({
          color: 0xFFFFFF,
          roughness,
          metalness,
        })
      );
      panel.translateY(Math.cos(i / sides * Math.PI * 2));
      panel.translateX(Math.sin(i / sides * Math.PI * 2));
      panel.translateZ(-length / 2);
      panel.rotateZ((-i) / sides * Math.PI * 2);
      mirrorGroup.add(panel);
    }

    mirrorGroup.position.z = -1 * (length + boundary);

    scene.add(mirrorGroup);

    pathTracer.setScene(scene, kaleidoCamera);
    invalidation.then(() => {
      mirrorGroup.removeFromParent();
      mirrorGroup.clear();
      resetSampleCount();
    });
  </script>
  <script id="126" type="text/x-typescript" pinned="">
    const hemisphereLight = new THREE.HemisphereLight(0xFFFFFF, background, 5);
    hemisphereLight.layers.enableAll();
    scene.add(hemisphereLight);

    invalidation.then(() => {
      hemisphereLight.removeFromParent();
      hemisphereLight.dispose();
    });
  </script>
  <script id="127" type="text/x-typescript" pinned="">
    const plainDirectionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.75);
    plainDirectionalLight.position.set(0, 0, 20);
    plainDirectionalLight.layers.set(PLAIN_LAYER);
    plainCamera.add(plainDirectionalLight);

    invalidation.then(() => {
      plainDirectionalLight.removeFromParent();
      plainDirectionalLight.dispose();
    });
  </script>
  <script id="147" type="text/x-typescript" pinned="">
    const kaleidoDirectionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.75);
    kaleidoDirectionalLight.position.set(0, 0, 20);
    kaleidoDirectionalLight.layers.set(KALEIDO_LAYER);
    kaleidoCamera.add(kaleidoDirectionalLight);

    invalidation.then(() => {
      kaleidoDirectionalLight.removeFromParent();
      kaleidoDirectionalLight.dispose();
    });
  </script>
  <script id="90" type="text/markdown">
    ### Rendering setup

    ${nav("rendering-setup")}
  </script>
  <script id="104" type="text/x-typescript">
    const scene = new THREE.Scene();
    scene.layers.enableAll();

    const kaleidoEnvironment = new GradientEquirectTexture();
    kaleidoEnvironment.bottomColor.set(0xFFFFFF);
    kaleidoEnvironment.bottomColor.set(background);
    kaleidoEnvironment.update();
    scene.environment = kaleidoEnvironment;
    scene.background = kaleidoEnvironment;

    invalidation.then(() => scene.clear());
  </script>
  <script id="136" type="text/markdown">
    <h4 id="rendering-setup--cameras">Cameras</h4>
    ${nav("rendering-setup--cameras")}
  </script>
  <script id="123" type="text/x-typescript" pinned="">
    const defaultPerspective = [45, 1, 1, 1000];
    const plainCamera = new THREE.PerspectiveCamera(...defaultPerspective);
    plainCamera.name = "PlainCamera";
    plainCamera.layers.set(PLAIN_LAYER);
    plainCamera.position.z = -1 * ((length * 2) + boundary);
    plainCamera.lookAt(new THREE.Vector3(0, 0, 0));
  </script>
  <script id="8" type="text/x-typescript" pinned="">
    const kaleidoPerspective = [75, 1, 0.5, 500];
    const kaleidoCamera = new THREE.PerspectiveCamera(...kaleidoPerspective);
    kaleidoCamera.name = "KaleidoCamera";
    kaleidoCamera.layers.enable(KALEIDO_LAYER);
    kaleidoCamera.position.z = -1 * ((length * 2) + boundary);
    kaleidoCamera.lookAt(new THREE.Vector3(0, 0, 0));

    scene.add(kaleidoCamera);
    invalidation.then(() => kaleidoCamera.removeFromParent());
  </script>
  <script id="135" type="text/markdown">
    <h4 id="rendering-setup--renderers">Renderers</h4>
    ${nav("rendering-setup--renderers")}
  </script>
  <script id="113" type="text/x-typescript" pinned="">
    const canvasSize = Math.floor(width / 2);
  </script>
  <script id="122" type="text/x-typescript" pinned="">
    const plainRenderer = new THREE.WebGLRenderer({
      canvas: plainCanvas,
      antialias: true,
      preserveDrawingBuffer: true
    });

    plainRenderer.setSize(canvasSize, canvasSize);
    plainRenderer.setPixelRatio(devicePixelRatio);

    plainRenderer.toneMapping = THREE.LinearToneMapping;
    plainRenderer.outputEncoding = THREE.sRGBEncoding;

    invalidation.then(() => plainRenderer.dispose());
  </script>
  <script id="4" type="text/x-typescript">
    const kaleidoRenderer = new THREE.WebGLRenderer({
      canvas: kaleidoCanvas,
      antialias: true,
      preserveDrawingBuffer: true
    });

    kaleidoRenderer.setSize(canvasSize, canvasSize);
    kaleidoRenderer.setPixelRatio(devicePixelRatio);

    kaleidoRenderer.toneMapping = THREE.LinearToneMapping;
    kaleidoRenderer.outputEncoding = THREE.sRGBEncoding;

    invalidation.then(() => kaleidoRenderer.dispose());
  </script>
  <script id="103" type="text/x-typescript" pinned="">
    refresh;

    const pathTracer = new WebGLPathTracer(kaleidoRenderer);

    pathTracer.bounces = bounces + 1;
    pathTracer.renderScale = Math.max(1 / devicePixelRatio, 0.5);
    pathTracer.tiles.setScalar(1);
    // pathTracer.dynamicLowRes = true;
    // pathTracer.lowResScale = 0.5;
    pathTracer.setBVHWorker(bvhWorker);

    pathTracer.setScene(scene, kaleidoCamera);

    invalidation.then(() => {
      pathTracer.dispose();
      resetSampleCount();
    });
  </script>
  <script id="148" type="text/x-typescript" pinned="">
    const bvhWorker = new GenerateMeshBVHWorker()
  </script>
  <script id="133" type="text/markdown">
    <h4 id="rendering-setup--controls">Controls</h4>
    ${nav("rendering-setup--controls")}
  </script>
  <script id="124" type="text/x-typescript" pinned="">
    const plainControls = new OrbitControls(plainCamera, plainCanvas);
    plainControls.target.set(0, 0, 0);

    plainControls.update();

    invalidation.then(() => {
      plainControls.dispose();
    });
  </script>
  <script id="88" type="text/x-typescript" pinned="">
    const kaleidoControls = new OrbitControls(kaleidoCamera, kaleidoCanvas);
    kaleidoControls.enablePan = false;
    kaleidoControls.target.set(0, 0, 0);

    const angleLimit = 3;

    const currentAzimuth = kaleidoControls.getAzimuthalAngle();
    kaleidoControls.maxAzimuthAngle = currentAzimuth + THREE.MathUtils.degToRad(angleLimit);
    kaleidoControls.minAzimuthAngle = currentAzimuth - THREE.MathUtils.degToRad(angleLimit);
    const currentPolar = kaleidoControls.getPolarAngle();
    kaleidoControls.maxPolarAngle = currentPolar + THREE.MathUtils.degToRad(angleLimit);
    kaleidoControls.minPolarAngle = currentPolar - THREE.MathUtils.degToRad(angleLimit);

    kaleidoControls.update();

    invalidation.then(() => {
      kaleidoControls.dispose();
    });
  </script>
  <script id="141" type="text/x-typescript" pinned="">
    const kaleidoControlsChange = () => {
      pathTracer.updateCamera();
      resetSampleCount();
    };
    kaleidoControls.addEventListener("change", kaleidoControlsChange);
    console.log(kaleidoControls)

    invalidation.then(() => {
      kaleidoControls.removeEventListener("change", kaleidoControlsChange);
    });
  </script>
  <script id="140" type="text/x-typescript" pinned="">
    function plainControlsChange() {
      // const cameraWorldQuat = new THREE.Quaternion();
      // plainCamera.getWorldQuaternion(cameraWorldQuat); .invert()
      // console.log(plainControls._lastQuaternion, plainCamera.quaternion)
      // const halfRot = new THREE.Quaternion();
      // halfRot.setFromAxisAngle(new THREE.Vector3(0, -1, 0), Math.PI)

      kaleidoShapeGroup.quaternion.copy(plainCamera.quaternion);
      // kaleidoShapeGroup.quaternion.multiply(halfRot)
      kaleidoShapeGroup.matrixWorldNeedsUpdate = true;

      pathTracer.setScene(scene, kaleidoCamera);
      pathTracer.updateCamera();
      resetSampleCount();
    }

    plainControls.addEventListener("change", plainControlsChange);
    invalidation.then(() => {
      plainControls.removeEventListener("change", plainControlsChange);
    });
  </script>
  <script id="5" type="text/x-typescript" pinned="">
    const plainCanvas = container.querySelector("#plain");
    const kaleidoCanvas = container.querySelector("#kaleido");
  </script>
  <script id="132" type="text/markdown">
    <h4 id="rendering-setup--render-loop">Render loop</h4>
    ${nav("rendering-setup--render-loop")}
  </script>
  <script id="118" type="text/x-typescript" pinned="">
    const tick = (async function* () {
      do {
        yield null;

        plainControls.update();
        kaleidoControls.update();

        plainRenderer.render(scene, plainCamera);

        if (
          !enablePathTracing ||
          kaleidoControls.state === 0 ||
          plainControls.state === 0
        ) {
          kaleidoRenderer.render(scene, kaleidoCamera);
        } else {
          if (sampleCount <= samples) {
            try {
              pathTracer.renderSample();
            } catch (e) {
              console.log(e);
              throw e;
            }
            renderSampleCount(sampleCount, samples);
            incrementSampleCount();
          }
        }

      } while (true);
    })();
  </script>
  <script id="105" type="text/x-typescript" pinned="">
    samples;
    enablePathTracing;

    const sampleCount = Mutable(0);

    const resetSampleCount = () => sampleCount.value = 0;
    const incrementSampleCount = () => sampleCount.value += 1;

    const samplesOverlay = container.querySelector("#samples-overlay");
    const renderSampleCount = (count, total) => samplesOverlay.innerText = `${count}/${total}`;

    invalidation.then(() => resetSampleCount());
  </script>
  <script id="125" type="text/x-typescript" pinned="">
    const vertexShader = `
      varying vec3 vNormal;

      void main() {
        vNormal = normal;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const normalFragmentShader = `
      varying vec3 vNormal;

      void main(void)
      {
          vec3 view_nv  = normalize(vNormal);
          vec3 nv_color = view_nv * 0.5 + 0.5;
          gl_FragColor  = vec4(nv_color, 1.0);
      }
    `;
  </script>
  <script id="130" type="text/x-typescript" pinned="">
    const PLAIN_LAYER = 3;
    const KALEIDO_LAYER = 4;
  </script>
  <script id="3" type="text/x-typescript" pinned="">
    const SHAPE_MAP = {
      Box: THREE.BoxGeometry,
      Cylinder: THREE.CylinderGeometry,
      Sphere: THREE.SphereGeometry,
      Torus: THREE.TorusGeometry,
      Icosahedron: THREE.IcosahedronGeometry,
      Tetrahedron: THREE.TetrahedronGeometry,
      Octahedron: THREE.OctahedronGeometry,
    };

    type ShapeType = keyof SHAPE_MAP;

    const shapeColors = d3.scaleOrdinal(Object.keys(SHAPE_MAP), d3.schemeObservable10);
  </script>
  <script id="64" type="text/x-typescript" pinned="">
    const MATERIAL_MAP = {
      Normal: THREE.ShaderMaterial,
      Lambert: THREE.MeshLambertMaterial,
      Phong: THREE.MeshPhongMaterial,
    };

    type MaterialType = keyof SHAPE_MAP;
  </script>
  <script id="18" type="text/markdown">
    ### TODO

    - [ ] “variation scale” option
    - [ ] random distribution options
  </script>
  <script id="58" type="text/markdown">
    ## Config setup

    ${nav("config-setup")}
  </script>
  <script id="11" type="text/x-typescript">
    interface ShapesConfig {
      count: number;
      boundary: number;
      size: {
        min: number;
        max: number;
      },
      types: ShapeType[],
    }

    const count = input(Inputs.range([1, 64], {step: 1, label: "Count", value: 20}));
    const boundary = input(Inputs.range([1, 64], {step: 1, label: "Boundary", value: 10}));
    const size = input(interval([1, 16], {step: 1, label: "Size", value: [1, 3]}));
    const types = input(Inputs.checkbox(Object.keys(SHAPE_MAP), {label: "Shape types", value: Object.keys(SHAPE_MAP)}));

    const shapesForm = [
      html`<h4>Shapes`,
      ...[count, boundary, size, types].map(i => i.element),
    ];
  </script>
  <script id="69" type="text/x-typescript" pinned="">
    interface MaterialConfig {
      wireframe: "none" | "some" | "all";
      material: MaterialType;
      materialColor: ColorScheme;
    }

    const wireframe = input(Inputs.radio(["none", "some", "all"], {label: "Wireframe", value: "none"}));
    const material = input(Inputs.select(Object.keys(MATERIAL_MAP), {label: "Material", value: "Lambert"}));
    const materialColor = input(Inputs.select(schemeKeys, {label: "Color", value: "schemeSpectral"}));

    const materialForm = [
      html`<h4>Material`,
      wireframe.element,
      material.element,
      materialColor.element
    ]
  </script>
  <script id="56" type="text/x-typescript">
    interface KaleidoConfig {
      sides: number;
      length: number;
      roughness: number;
      metalness: number;
    }

    const sides = input(Inputs.range([3, 4], {step: 1, label: "Number (sides)", value: 3}));
    const length = input(Inputs.range([1, 50], {step: 1, label: "Length", value: 5}));
    const roughness = input(Inputs.range([0, 1], {step: 0.01, label: "Roughness", value: 0.03}));
    const metalness = input(Inputs.range([0, 1], {step: 0.01, label: "Metalness", value: 1}));

    const kaleidoForm = [
        html`<h4>Mirrors`,
        ...[sides, length, roughness, metalness].map(i => i.element),
    ];
  </script>
  <script id="57" type="text/x-typescript">
    interface RenderConfig {
      enablePathTracing: boolean;
      background: string;
      bounces: number;
      samples: number;
    }

    const enablePathTracing = input(Inputs.toggle({label: "Enable path tracing", value: false}));
    const bounces = input(Inputs.range([1, 60], {step: 1, label: "Light bounces", value: 10}));
    const samples = input(Inputs.range([1, 1000], {step: 1, label: "Render samples", value: 200}));
    const background = input(Inputs.color({label: "Background color", value: "#EEEEEE"})); // #171720

    const renderingForm = [
        html`<h4>Rendering`,
      ...[enablePathTracing, bounces, samples, background].map(i => i.element)
    ];
  </script>
  <script id="51" type="text/x-typescript" hidden="">
    const useShapeDistribution = input(Inputs.toggle({label: "Control shape distribution?", value: true}));
    const useShapeDistributionToggle = useShapeDistribution.element;
  </script>
  <script id="42" type="text/x-typescript">
    const initialTypes = types.map(s => ({label: s, value: 100 / types.length}));
    const shapeDistribution = input(inputTemplate(
      categoricalSlider(initialTypes, {scope: "shapeDistribution", disabled: !useShapeDistribution}),
      {label: "Shape distribution", width: "100%", wrap: false}
    ));

    const shapeDistributionInput = [
      shapeDistribution.element,
      html`<style>
        .shapeDistribution {
          line-height: 1.5;
          margin-right: var(--length2);
        }
      </style>`
    ];
  </script>
  <script id="70" type="text/x-typescript" pinned="">
    const advancedForm = details({label: "Advanced"});
  </script>
  <script id="85" type="text/x-typescript" pinned="">
    advancedForm.contents = html.fragment`
      ${useShapeDistributionToggle}
      ${shapeDistributionInput}
    `;
  </script>
  <script id="22" type="text/markdown">
    ---

    ## Appendix

    ${nav("appendix")}
  </script>
  <script id="2" type="text/x-typescript" pinned="">
    import * as THREE from "npm:three@0.170.0";
    import { OrbitControls } from "npm:three@0.170.0/addons/controls/OrbitControls";
    import { EffectComposer } from "npm:three@0.170.0/addons/postprocessing/EffectComposer";
    import { RenderPass } from "npm:three@0.170.0/examples/jsm/postprocessing/RenderPass";
    import { ShaderPass } from "npm:three@0.170.0/examples/jsm/postprocessing/ShaderPass";
    import { OutputPass } from "npm:three@0.170.0/examples/jsm/postprocessing/OutputPass";
    import { KaleidoShader } from "npm:three@0.170.0/examples/jsm/shaders/KaleidoShader";
  </script>
  <script id="102" type="text/x-typescript" pinned="">
    import { WebGLPathTracer, GradientEquirectTexture } from "https://esm.sh/gh/gkjohnson/three-gpu-pathtracer";
  </script>
  <script id="120" type="text/x-typescript" pinned="">
    // https://github.com/gkjohnson/three-mesh-bvh/blob/master/src/workers/GenerateMeshBVHWorker.js
    // loads bundled worker from esm.sh and removes references to SharedArrayBuffer

    import { MeshBVH } from "npm:three-mesh-bvh";
    import { WorkerBase } from "npm:three-mesh-bvh/src/workers/utils/WorkerBase";
    import createBVHWorker from "https://esm.sh/three-mesh-bvh/src/workers/generateMeshBVH.worker.js?deps=three@0.170.0&worker";

    class GenerateMeshBVHWorker extends WorkerBase {
      constructor() {
        const worker = createBVHWorker();
        super(worker);
        this.name = "GenerateMeshBVHWorker";
      }

      runTask(worker, geometry, options = {}) {
        return new Promise((resolve, reject) => {
          if (
            geometry.getAttribute("position").isInterleavedBufferAttribute ||
            (geometry.index && geometry.index.isInterleavedBufferAttribute)
          ) {
            throw new Error(
              "GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes."
            );
          }

          worker.onerror = (e) => {
            reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));
          };

          worker.onmessage = (e) => {
            const {data} = e;

            if (data.error) {
              reject(new Error(data.error));
              worker.onmessage = null;
            } else if (data.serialized) {
              const { serialized, position } = data;
              const bvh = MeshBVH.deserialize(serialized, geometry, {setIndex: false});
              const boundsOptions = Object.assign(
                {setBoundingBox: true},
                options
              );

              // we need to replace the arrays because they're neutered entirely by the
              // webworker transfer.
              geometry.attributes.position.array = position;
              if (serialized.index) {
                if (geometry.index) {
                  geometry.index.array = serialized.index;
                } else {
                  const newIndex = new THREE.BufferAttribute(serialized.index, 1, false);
                  geometry.setIndex(newIndex);
                }
              }

              if (boundsOptions.setBoundingBox) {
                geometry.boundingBox = bvh.getBoundingBox(new THREE.Box3());
              }

              if (options.onProgress) {
                options.onProgress(data.progress);
              }

              resolve(bvh);
              worker.onmessage = null;
            } else if (options.onProgress) {
              options.onProgress(data.progress);
            }
          };

          const index = geometry.index ? geometry.index.array : null;
          const position = geometry.attributes.position.array;
          const transferable = [position];
          if (index) {
            transferable.push(index);
          }

          worker.postMessage(
            {
              index,
              position,
              options: {
                ...options,
                onProgress: null,
                includedProgressCallback: Boolean(options.onProgress),
                groups: [...geometry.groups],
              },
            },
            transferable.map((arr) => arr.buffer)
          );
        });
      }
    }
  </script>
  <script id="12" type="text/x-typescript" pinned="">
    import { interval } from "observable:@mootari/range-slider";
    import { inputTemplate } from "observable:@cubeghost/input-template-desktop";
    import { categoricalSlider } from "observable:@cubeghost/window-splitter-slider";
    import { conditionalShow } from "observable:@john-guerra/conditional-show"
  </script>
  <script id="63" type="text/x-typescript" pinned="">
    import * as schemes from "npm:d3-scale-chromatic";

    const schemeKeys = Object.keys(schemes).filter(k => k.startsWith("scheme"));
    const interpolateKeys = Object.keys(schemes).filter(k => k.startsWith("interpolate"));

    type ColorScheme = (typeof schemeKeys)[number];

    function getScaleForScheme(schemeKey: typeof schemeKeys) {
      const interpolateKey = schemeKey.replace("scheme", "interpolate");
      if (interpolateKeys.includes(interpolateKey)) {
        return d3.scaleSequential(d3[interpolateKey]);
      } else {
        return d3.scaleOrdinal(d3[schemeKey]);
      }
    }
  </script>
  <script id="82" type="text/x-typescript" pinned="">
    const PAGE_SECTIONS = {
      "top": "Config",
      "scene-generation": "Scene generation",
      "rendering-setup": {
        label: "Rendering setup",
        children: {
          "rendering-setup--cameras": "Cameras",
          "rendering-setup--renderers": "Renderers",
          "rendering-setup--controls": "Controls",
          "rendering-setup--render-loop": "Render loop",
        }
      },
      "config-setup": "Config setup",
      "appendix": "Appendix"
    };

    function nav(current: keyof PAGE_SECTIONS) {
      const link = ([id, label], i) => htl.html.fragment`${i ? "•" : ""}<a href=${id === current ? null : `#${id}`}>${label}`;

      return htl.html`<div style="
        font: 13px/1.5 var(--sans-serif);
        display: flex;
        gap: 1ch;
        padding-bottom: 0.5rem;
      ">${
        Object.entries(PAGE_SECTIONS).flatMap((entry, i) => {
          if (typeof entry[1] === "string") {
            return link(entry, i);
          } else {
            const [id, { label, children }] = entry;
            const childIds = Object.keys(children);
            if (id === current || childIds.includes(current)) {
              return [htl.html.fragment`${i ? "•" : ""}<span>[`, ...Object.entries(children).map(link), htl.html`<span>]`]
            } else {
              return link([id, label], i);
            }
          }
        })
      }`
    }
  </script>
  <script id="75" type="text/x-typescript" pinned="">
    // creates a `<details>` element that can stay open even as contents change
    // contents must be set on the `.contents` property
    function details({label, defaultOpen} = {}) {
      let open = Mutable(defaultOpen ?? false);

      const element = htl.html`<details ${open.value ? {open: true} : {}}>
        <summary>${label}</summary>
      </details>`;

      element.addEventListener("toggle", (event) => {
        open.value = element.open;
      });

      return Object.defineProperty(
        element,
        "contents",
        {
          get: () => element.querySelectorAll("&>*:not(summary)"),
          set: (contents) => {
            element.querySelectorAll("&>*:not(summary)").forEach(n => element.removeChild(n));
            element.appendChild(contents);
            element.open = open.value;
          }
        }
      );
    }
  </script>
  <script id="30" type="text/x-typescript" pinned="">
    const refresh = input(Inputs.button("Generate", {value: null, reduce: () => Date.now()}));

    display(html`<div class="refresh-button">${refresh.element}</div>`);
  </script>
  <script id="31" type="text/html" pinned="">
    <style>
      .refresh-button {
        position: absolute; top: 3rem; left: ${width}px; transform: translateX(-50%)
      }
      .refresh-button form {
        width: unset !important;
      }
    </style>
  </script>
  <script id="21" type="text/x-typescript" pinned="">
    // https://github.com/observablehq/notebook-kit/discussions/32
    function input(element) {
      const generator = Generators.input(element);
      generator.element = element;
      return generator;
    }

    // cannot figure out how to make a generator out of Inputs.form
  </script>
  <script id="94" type="text/x-typescript" pinned="">
    // attempt at auto-rotate with TrackballControls (to get around polar limitation of OrbitControls)

    // const controls = new TrackballControls(camera, controlElement);
    // controls.rotateSpeed = 1.5;
    // controls.screen.width = width / 2; // adjust rotation amount relative to width of each canvas

    // let shapeAngle = 0;
    // const shapeQuaternion = new THREE.Quaternion();

    // if (autoRotate && controls.state === -1) {
    //   // const deg = THREE.MathUtils.radToDeg(controls._lastAngle);
    //   // const _angle = THREE.MathUtils.degToRad(deg + 0.05);
    //   // quaternion.setFromAxisAngle(controls._lastAxis, _angle);
    //   // controls.object.up.applyQuaternion(quaternion);
    //   // controls._eye.applyQuaternion(quaternion);
    //   // controls._lastAngle = _angle;
    //   shapeAngle = (shapeAngle + 0.01) % (Math.PI * 2);
    //   shapeQuaternion.setFromAxisAngle(controls._lastAxis, shapeAngle);
    //   shapeGroup.rotation.setFromQuaternion(shapeQuaternion);
    //   // shapeGroup.rotation.x = rotX;
    //   // shapeGroup.rotation.y = rotY;
    //   // rotX += 0.01;
    //   // rotY += 0.01 / 2;
    // }
  </script>
</notebook>
