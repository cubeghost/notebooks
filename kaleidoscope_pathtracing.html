<!doctype html>
<notebook theme="air">
  <title>three.js kaleidoscope playground</title>
  <script id="1" type="text/markdown">
    # three.js kaleidoscope playground
    a realistic mirror-based kaleidoscope based on Leif Gehrmann’s [kaleidoscope-threejs-path-tracing](https://github.com/leifgehrmann/kaleidoscope-threejs-path-tracing)

    <details>
      <summary>Notes</summary>
      ${md`
      - Sometimes the path tracer output disappears, unclear why
      - Sometimes with the fake Normal material the shapes are completely black, [maybe a floating point error?](https://github.com/gkjohnson/three-gpu-pathtracer/issues/429)
      `}
    </details>
    <details>
      <summary>TODO</summary>
      ${md`
      - Fix panning
      - Add input debouncing
      - Add option for Normal-material area light intensity
      - Add option to hide/dismiss sample count
      - Add download button
      `}
    </details>
    <hr style="margin: 0">

    <div id="top" />
    ${nav("top")}
  </script>
  <script id="49" type="text/html">
    <div style="display: flex; max-width: 100%;" id="form">
      <div>
        ${shapesForm}
        ${materialForm}
        <br>
        ${refreshShapesButton}
      </div>
      <div>
        ${kaleidoForm}
        <br />
        ${renderingForm}
      </div>
    </div>
    <div>${advancedForm}</div>
  </script>
  <script id="6" type="text/x-typescript">
    const container = display(html`
    <div style="position: relative;">
      <div id="canvases" style="display: flex;">
        <canvas id="plain"></canvas>
        <canvas id="kaleido"></canvas>
      </div>
      <div id="samples-overlay" style="position: absolute; top: 0; left: 50%;"></div>
      <small>Drag to rotate, scroll to zoom, right click to pan</small>
    </div>`);
  </script>
  <script id="89" type="text/markdown">
    ### Scene generation
  </script>
  <script id="177" type="text/html">
    <h4 id="scene-generation--shapes">Shapes</h4>
    ${nav("scene-generation--shapes")}
  </script>
  <script id="17" type="text/x-typescript">
    interface Shape {
      geometry: {
        Class: typeof SHAPE_MAP[keyof SHAPE_MAP];
        args: number[];
      };
      positon: [number, number, number];
      rotation: [number, number, number];
      wireframe: boolean;
      color: string;
    }

    function generateShapes(config: ShapeConfig): Shape[] {
      const size = d3.randomInt(config.size[0], config.size[1]);
      const positionScale = d3.randomInt(-config.boundary / 2, config.boundary / 2);
      const rotationScale = d3.randomInt(0, Math.PI * 2);
      const geometryScale = d3.scaleQuantize(config.types);
      const colorScale = getScaleForScheme(config.color);
      const wireframeScale = d3.scaleQuantize([true, false]);
      const random = d3.randomUniform();

      const shapeArray: (keyof SHAPE_MAP) = useShapeDistribution
        ? d3.shuffle(shapeDistribution.flatMap((d) => Array.from({length: config.count * (d.value / 100)}, () => d.label)))
        : Array.from({length: config.count}, () => geometryScale(random()));

      return shapeArray.map((shapeName) => {
        const wireframe = config.wireframe === "all" ? true :
                          config.wireframe === "none" ? false :
                          wireframeScale(random());
        const color = colorScale(random());

        const geometryClass = SHAPE_MAP[shapeName];
        const geometryArgs = (() => {
          switch (geometryClass) {
            case THREE.BoxGeometry:
              return [size(), size(), size()];
            case THREE.CylinderGeometry:
              const end = size();
              return [end, end, size()];
            case THREE.SphereGeometry: {
              const diameter = size();
              if (wireframe) {
                // variation on segment count
                const segments = d3.max([8, d3.min([diameter * 4, 32])]);
                const v = d3.randomLogNormal(0, diameter / 3);
                return [diameter, segments - v(), segments - v()];
              } else {
                return [diameter, 32, 32];
              }
            }
            case THREE.TorusGeometry: {
              const diameter = size();
              const tube = d3.randomUniform(0.2, 0.8);
              if (wireframe) {
                // variation on segment count
                const segments = d3.max([8, d3.min([diameter * 4, 32])]);
                const v = d3.randomLogNormal(0, diameter / 3);
                return [diameter, diameter * tube(), segments - v(), (segments - v()) * 4];
              } else {
                return [diameter, diameter * tube(), 32, 64];
              }
            }
            case THREE.TorusKnotGeometry: {
              // TODO other 2 args
              const diameter = size();
              const tube = d3.randomUniform(0.2, 0.5);
              if (wireframe) {
                // variation on segment count
                const segments = d3.max([8, d3.min([diameter * 4, 32])]);
                const v = d3.randomLogNormal(0, diameter / 3);
                return [diameter, diameter * tube(), (segments - v()) * 4, segments - v()];
              } else {
                return [diameter, diameter * tube(), 128, 64];
              }
            }
            case THREE.IcosahedronGeometry:
            case THREE.TetrahedronGeometry:
            case THREE.OctahedronGeometry:
              return [size(), 0];
            default:
              return [];
          }
        })();

        const position = Array.from({length: 3}, positionScale);
        const rotation = Array.from({length: 3}, rotationScale);

        return {
          geometry: {
            Class: geometryClass,
            args: geometryArgs,
          },
          position,
          rotation,
          wireframe,
          color,
        };
      });
    };
  </script>
  <script id="114" type="text/x-typescript" pinned="">
    void refreshShapes;

    const shapes = generateShapes({count, boundary, size, types, wireframe, color: materialColor});

    display(shapes);
  </script>
  <script id="66" type="text/x-typescript" pinned="">
    function getMaterial(shape: Shape) {
      const {color} = shape;

      switch (materialType) {
        case "Phong":
          return new THREE.MeshPhongMaterial({color, emissive: 0x000000, specular: background, shininess: 500});
        case "Lambert":
          return new THREE.MeshLambertMaterial({color});
        case "Normal": {
          return new THREE.MeshPhysicalMaterial({
            color: 0xFFFFFF,
            emissive: 0x000000,
            reflectivity: 0,
            roughness: 1,
            metalness: 0,
            vertexColors: true,
          });
        }
        default:
          throw new Error(`Unimplmented material "${materialType}"`)
      }
    }
  </script>
  <script id="174" type="text/x-typescript" pinned="">
    const useNormalColors = materialType === "Normal"
  </script>
  <script id="13" type="text/x-typescript" pinned="">
    const shapeGroup = new THREE.Group();
    shapeGroup.name = "ShapeGroup";
    shapeGroup.layers.enableAll();

    for (const shape of shapes) {
      const geometry = new shape.geometry.Class(...shape.geometry.args);
      if (useNormalColors) {
        geometry.setAttribute("color", new THREE.Float32BufferAttribute(new Array(geometry.getAttribute("normal").count * 3), 3));
      }

      const material = getMaterial(shape);
      const mesh = new THREE.Mesh(geometry, material);

      mesh.position.fromArray(shape.position);
      mesh.rotation.fromArray(shape.rotation);
      mesh.layers.enableAll();

      if (useNormalColors) {
        material.castShadow = false;

        setNormalColors(mesh, geometry);

        material.onBeforeRender = function onBeforeRender(renderer, scene, camera, geometry, object, group) {
          setNormalColors(object, geometry);
        }
      }

      shapeGroup.add(mesh);
    }

    display(shapeGroup);

    invalidation.then(() => {
      shapeGroup.clear();
    });
  </script>
  <script id="178" type="text/x-typescript" pinned="">
    scene.add(shapeGroup);

    pathTracer.setScene(scene, kaleidoCamera);

    invalidation.then(() => {
      shapeGroup.removeFromParent();
      resetRender();
    });
  </script>
  <script id="162" type="text/x-typescript" pinned="">
    function normalToColor(normal, object) {
      // gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );
      normal.applyMatrix3(object.normalMatrix).multiplyScalar(0.5).addScalar(0.5);
      return normal;
    }

    function setNormalColors(object, geometry) {
      const colors = geometry.getAttribute("color");
      const normals = geometry.getAttribute("normal");

      for (let i = 0; i < colors.count; i++) {
        const normal = new THREE.Vector3().fromBufferAttribute(normals, i);
        const color = normalToColor(normal, object);
        colors.setXYZ(i, color.x, color.y, color.z);
      }

      colors.needsUpdate = true;
    }
  </script>
  <script id="175" type="text/x-typescript" pinned="">
    function updateShapeNormalColors() {
      if (useNormalColors) {
        for (const shape of shapeGroup.children) {
          setNormalColors(shape, shape.geometry);
        }
      }
    }
  </script>
  <script id="176" type="text/html">
    <h4 id="scene-generation--mirrors">Mirrors</h4>
    ${nav("scene-generation--mirrors")}
  </script>
  <script id="97" type="text/x-typescript" pinned="">
    const mirrorGroup = new THREE.Group();
    mirrorGroup.name = "MirrorGroup";
    mirrorGroup.layers.set(KALEIDO_LAYER);

    const innerMirrorGroup = new THREE.Group();
    innerMirrorGroup.name = "InnerMirrorGroup";
    innerMirrorGroup.layers.set(KALEIDO_LAYER);

    if (useCylinderMirror) {
      const cylinder = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1, length, sides, 1, true),
        new THREE.MeshStandardMaterial({
          color: 0xFFFFFF,
          roughness,
          metalness,
          side: THREE.BackSide,
        })
      );

      cylinder.translateZ(-length / 2);
      cylinder.rotation.set(0, Math.PI / 2, Math.PI / 2);

      cylinder.layers.set(KALEIDO_LAYER);
      innerMirrorGroup.add(cylinder);
    } else {
      const mirrorApothem = 1;
      const mirrorRadius = mirrorApothem / Math.cos(Math.PI / sides);
      const mirrorSide = 2 * mirrorRadius * Math.sin(Math.PI / sides);

      for (let i = 0; i < sides; i++) {
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(mirrorSide, 0.02, length),
          new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness,
            metalness,
          })
        );
        panel.castShadow = false;

        panel.translateY(Math.cos((i / sides) * (Math.PI * 2)) * mirrorApothem);
        panel.translateX(Math.sin((i / sides) * (Math.PI * 2)) * mirrorApothem);
        panel.translateZ(-length / 2);

        panel.rotateZ((-i) / sides * (Math.PI * 2));

        panel.layers.set(KALEIDO_LAYER);
        innerMirrorGroup.add(panel);
      }
    }

    mirrorGroup.add(innerMirrorGroup);

    display(mirrorGroup);

    invalidation.then(() => {
      mirrorGroup.clear();
    });
  </script>
  <script id="181" type="text/x-typescript" pinned="">
    mirrorGroup.position.copy(kaleidoCamera.position);
    mirrorGroup.quaternion.copy(kaleidoCamera.quaternion);

    scene.add(mirrorGroup);
    pathTracer.setScene(scene, kaleidoCamera);

    invalidation.then(() => {
      mirrorGroup.removeFromParent();
      resetRender();
    });
  </script>
  <script id="180" type="text/x-typescript" pinned="">
    innerMirrorGroup.rotation.z = THREE.MathUtils.degToRad(rotation);

    pathTracer.setScene(scene, kaleidoCamera);

    invalidation.then(() => {
      resetRender();
    });
  </script>
  <script id="165" type="text/html">
    <h4 id="scene-generation--lights">Lights</h4>
    ${nav("scene-generation--lights")}
  </script>
  <script id="126" type="text/x-typescript" pinned="">
    const hemisphereLight = new THREE.HemisphereLight(0xFFFFFF, background, 5);
    hemisphereLight.layers.enableAll();
    if (!useNormalColors) scene.add(hemisphereLight);

    pathTracer.updateLights();

    invalidation.then(() => {
      hemisphereLight.removeFromParent();
      hemisphereLight.dispose();
    });
  </script>
  <script id="127" type="text/x-typescript" pinned="">
    const plainDirectionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.75);
    plainDirectionalLight.position.set(0, 0, 20);
    plainDirectionalLight.layers.set(PLAIN_LAYER);
    if (!useNormalColors) plainCamera.add(plainDirectionalLight);

    pathTracer.updateLights();

    invalidation.then(() => {
      plainDirectionalLight.removeFromParent();
      plainDirectionalLight.dispose();
    });
  </script>
  <script id="147" type="text/x-typescript" pinned="">
    const kaleidoDirectionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.75);
    kaleidoDirectionalLight.position.set(0, 0, 20);
    kaleidoDirectionalLight.layers.set(KALEIDO_LAYER);
    if (!useNormalColors) kaleidoCamera.add(kaleidoDirectionalLight);

    pathTracer.updateLights();

    invalidation.then(() => {
      kaleidoDirectionalLight.removeFromParent();
      kaleidoDirectionalLight.dispose();
    });
  </script>
  <script id="152" type="text/x-typescript" pinned="">
    // lights Normal-colored shapes with the inverse of the environment color

    RectAreaLightUniformsLib.init();

    const areaLightGroup = new THREE.Group();
    areaLightGroup.name = "AreaLightCameraGroup";
    areaLightGroup.layers.enableAll();

    areaLightGroup.position.copy(kaleidoCamera.position);
    areaLightGroup.quaternion.copy(kaleidoCamera.quaternion);

    const backgroundColor = new THREE.Color(background);
    const inverseColor = new THREE.Color(1 - backgroundColor.r, 1 - backgroundColor.g, 1 - backgroundColor.b);

    const areaLightSize = boundary * 1.5;
    // TODO add experimental option for intensity
    const areaLightArgs = [inverseColor, 2.5, areaLightSize, areaLightSize];
    const areaLightAngle = THREE.MathUtils.degToRad(30);

    const centerAreaLight = new THREE.RectAreaLight(...areaLightArgs);
    centerAreaLight.position.set(0, 0, 1);

    const topAreaLight = new THREE.RectAreaLight(...areaLightArgs);
    const rightAreaLight = new THREE.RectAreaLight(...areaLightArgs);
    const bottomAreaLight = new THREE.RectAreaLight(...areaLightArgs);
    const leftAreaLight = new THREE.RectAreaLight(...areaLightArgs);

    topAreaLight.position.set(0, areaLightSize, 1);
    topAreaLight.rotation.set(-areaLightAngle, 0, 0);

    rightAreaLight.position.set(-areaLightSize, 0, 1);
    rightAreaLight.rotation.set(0, -areaLightAngle, 0);

    bottomAreaLight.position.set(0, -areaLightSize, 1);
    bottomAreaLight.rotation.set(areaLightAngle, 0, 0);

    leftAreaLight.position.set(areaLightSize, 0, 1);
    leftAreaLight.rotation.set(0, areaLightAngle, 0);

    for (const areaLight of [centerAreaLight, topAreaLight, rightAreaLight, bottomAreaLight, leftAreaLight]) {
      areaLight.layers.enableAll();
      areaLightGroup.add(areaLight);
    }

    if (useNormalColors) {
      scene.add(areaLightGroup);
    }

    pathTracer.updateLights();

    invalidation.then(() => {
      areaLightGroup.removeFromParent();
      areaLightGroup.clear();

      // centerAreaLight.dispose();
      for (const areaLight of [centerAreaLight, topAreaLight, rightAreaLight, bottomAreaLight, leftAreaLight]) {
        areaLight.dispose();
      }
    });
  </script>
  <script id="90" type="text/markdown">
    ### Rendering setup

    ${nav("rendering-setup")}
  </script>
  <script id="104" type="text/x-typescript" pinned="">
    const scene = new THREE.Scene();
    scene.layers.enableAll();

    display(scene);

    invalidation.then(() => {
      scene.clear();
    });
  </script>
  <script id="156" type="text/x-typescript" pinned="">
    const backgroundColor = new THREE.Color(background);

    const kaleidoEnvironment = new GradientEquirectTexture();
    kaleidoEnvironment.topColor.set(backgroundColor.clone().offsetHSL(0, 0, 0.25));
    kaleidoEnvironment.bottomColor.set(backgroundColor);
    kaleidoEnvironment.update();

    scene.environment = kaleidoEnvironment;
    scene.background = kaleidoEnvironment;

    pathTracer.updateEnvironment();

    invalidation.then(() => {
      kaleidoEnvironment.dispose();
      resetRender();
    });
  </script>
  <script id="136" type="text/markdown">
    <h4 id="rendering-setup--cameras">Cameras</h4>
    ${nav("rendering-setup--cameras")}
  </script>
  <script id="123" type="text/x-typescript" pinned="">
    const defaultPerspective = [45, 1, 1, 1000];
    const plainCamera = new THREE.PerspectiveCamera(...defaultPerspective);
    plainCamera.name = "PlainCamera";
    plainCamera.layers.set(PLAIN_LAYER);
    plainCamera.position.z = -1 * ((length * 2) + boundary);
    plainCamera.lookAt(new THREE.Vector3(0, 0, 0));

    scene.add(plainCamera);

    display(plainCamera);

    invalidation.then(() => plainCamera.removeFromParent());
  </script>
  <script id="8" type="text/x-typescript" pinned="">
    const kaleidoPerspective = [75, 1, 0.5, 500];
    const kaleidoCamera = new THREE.PerspectiveCamera(...kaleidoPerspective);
    kaleidoCamera.name = "KaleidoCamera";
    kaleidoCamera.layers.enableAll();
    kaleidoCamera.position.z = -1 * ((length * 2) + boundary);
    kaleidoCamera.lookAt(new THREE.Vector3(0, 0, 0));

    scene.add(kaleidoCamera);

    display(kaleidoCamera);

    invalidation.then(() => kaleidoCamera.removeFromParent());
  </script>
  <script id="135" type="text/markdown">
    <h4 id="rendering-setup--renderers">Renderers</h4>
    ${nav("rendering-setup--renderers")}
  </script>
  <script id="113" type="text/x-typescript" pinned="">
    const canvasSize = Math.floor(width / 2);
  </script>
  <script id="122" type="text/x-typescript" pinned="">
    const plainRenderer = new THREE.WebGLRenderer({
      canvas: plainCanvas,
      antialias: true,
      preserveDrawingBuffer: true
    });

    plainRenderer.setSize(canvasSize, canvasSize);
    plainRenderer.setPixelRatio(devicePixelRatio);

    plainRenderer.toneMapping = THREE.LinearToneMapping;
    plainRenderer.outputEncoding = THREE.sRGBEncoding;
    plainRenderer.outputColorSpace = THREE.LinearSRGBColorSpace;

    display(plainRenderer);

    invalidation.then(() => plainRenderer.dispose());
  </script>
  <script id="4" type="text/x-typescript" pinned="">
    const kaleidoRenderer = new THREE.WebGLRenderer({
      canvas: kaleidoCanvas,
      antialias: true,
      preserveDrawingBuffer: true,
    });

    kaleidoRenderer.setSize(canvasSize, canvasSize);
    kaleidoRenderer.setPixelRatio(devicePixelRatio);

    kaleidoRenderer.toneMapping = THREE.LinearToneMapping;
    kaleidoRenderer.outputEncoding = THREE.sRGBEncoding;
    kaleidoRenderer.outputColorSpace = THREE.LinearSRGBColorSpace;

    display(kaleidoRenderer);

    invalidation.then(() => kaleidoRenderer.dispose());
  </script>
  <script id="103" type="text/x-typescript" pinned="">
    const pathTracer = new WebGLPathTracer(kaleidoRenderer);

    pathTracer.bounces = bounces + 1;
    pathTracer.renderScale = Math.max(1 / devicePixelRatio, 0.5);
    pathTracer.tiles.setScalar(1);
    pathTracer.dynamicLowRes = dynamicLowRes;
    pathTracer.lowResScale = 0.5;
    pathTracer.setBVHWorker(bvhWorker);

    pathTracer.setScene(scene, kaleidoCamera);

    display(pathTracer);

    invalidation.then(() => {
      pathTracer.dispose();
      resetSampleCount();
    });
  </script>
  <script id="148" type="text/x-typescript" pinned="">
    const bvhWorker = new GenerateMeshBVHWorker();
  </script>
  <script id="133" type="text/markdown">
    <h4 id="rendering-setup--controls">Controls</h4>
    ${nav("rendering-setup--controls")}
  </script>
  <script id="124" type="text/x-typescript" pinned="">
    const plainControls = new OrbitControls(plainCamera, plainCanvas);
    kaleidoControls.enablePan = false;
    plainControls.target.set(0, 0, 0);

    plainControls.update();

    display(plainControls);

    invalidation.then(() => plainControls.dispose());
  </script>
  <script id="88" type="text/x-typescript" pinned="">
    const kaleidoControls = new OrbitControls(kaleidoCamera, kaleidoCanvas);
    kaleidoControls.enablePan = false;
    kaleidoControls.target.set(0, 0, 0);

    kaleidoControls.update();

    display(kaleidoControls);

    invalidation.then(() => kaleidoControls.dispose());
  </script>
  <script id="168" type="text/x-typescript" pinned="">
    void resetCameras;

    invalidation.then(() => {
      plainControls.reset();
      kaleidoControls.reset();
    });
  </script>
  <script id="149" type="text/x-typescript" pinned="">
    // TODO also figure out panning

    const azimuthalDelta = Mutable(0);
    const setAzimuthalDelta = (rad) => azimuthalDelta.value = rad;

    const polarDelta = Mutable(0);
    const setPolarDelta = (rad) => polarDelta.value = rad;
  </script>
  <script id="184" type="text/x-typescript" pinned="">
    display({azimuthalDelta, polarDelta})
  </script>
  <script id="140" type="text/x-typescript" pinned="">
    function plainControlsChange() {
      console.log("plainControlsChange")
      kaleidoControls.object.position.copy(plainControls.object.position);
      kaleidoControls.object.setRotationFromQuaternion(plainControls.object.quaternion);

      kaleidoControls._rotateLeft(azimuthalDelta);
      kaleidoControls._rotateUp(polarDelta);
      kaleidoControls.update();

      mirrorGroup.position.copy(plainControls.object.position);
      mirrorGroup.setRotationFromQuaternion(plainControls.object.quaternion);
      areaLightGroup.position.copy(plainControls.object.position);
      areaLightGroup.setRotationFromQuaternion(plainControls.object.quaternion);

      pathTracer.setScene(scene, kaleidoCamera);
      pathTracer.updateCamera();
      resetRender();
    }

    plainControls.addEventListener("change", plainControlsChange);

    invalidation.then(() => {
      plainControls.removeEventListener("change", plainControlsChange);
    });
  </script>
  <script id="151" type="text/x-typescript" pinned="">
    const kaleidoAngleRange = THREE.MathUtils.degToRad(1);

    function kaleidoControlsStart() {
      const currentAzimuth = plainControls.getAzimuthalAngle();
      const currentPolar = plainControls.getPolarAngle();
      kaleidoControls.maxAzimuthAngle = currentAzimuth + kaleidoAngleRange;
      kaleidoControls.minAzimuthAngle = currentAzimuth - kaleidoAngleRange;
      kaleidoControls.maxPolarAngle = currentPolar + kaleidoAngleRange;
      kaleidoControls.minPolarAngle = currentPolar - kaleidoAngleRange;
      kaleidoControls.update();
    }

    function kaleidoControlsEnd() {
      // defaults
      kaleidoControls.maxAzimuthAngle = plainControls.maxAzimuthAngle;
      kaleidoControls.minAzimuthAngle = plainControls.minAzimuthAngle;
      kaleidoControls.maxPolarAngle = plainControls.maxPolarAngle;
      kaleidoControls.minPolarAngle = plainControls.minPolarAngle;
      kaleidoControls.update();
    }

    function kaleidoControlsChange(event) {
      // only calculate delta when change originates from controls2
      if (plainControls.state === -1) {
        setAzimuthalDelta(plainControls.getAzimuthalAngle() - kaleidoControls.getAzimuthalAngle());
        setPolarDelta(plainControls.getPolarAngle() - kaleidoControls.getPolarAngle());

        pathTracer.setScene(scene, kaleidoCamera);
        pathTracer.updateCamera();
        resetRender();
      }
    }

    if (lockKaleidoAngle) {
      kaleidoControls.addEventListener("start", kaleidoControlsStart);
      kaleidoControls.addEventListener("end", kaleidoControlsEnd);
    }
    kaleidoControls.addEventListener("change", kaleidoControlsChange);

    invalidation.then(() => {
      kaleidoControls.removeEventListener("start", kaleidoControlsStart);
      kaleidoControls.removeEventListener("end", kaleidoControlsEnd);
      kaleidoControls.removeEventListener("change", kaleidoControlsChange);
    });
  </script>
  <script id="5" type="text/x-typescript" pinned="">
    const plainCanvas = container.querySelector("#plain");
    const kaleidoCanvas = container.querySelector("#kaleido");
  </script>
  <script id="132" type="text/markdown">
    <h4 id="rendering-setup--render-loop">Render loop</h4>
    ${nav("rendering-setup--render-loop")}
  </script>
  <script id="118" type="text/x-typescript" pinned="">
    const tick = (async function* () {
      do {
        yield null;

        plainControls.update();
        kaleidoControls.update();

        plainRenderer.render(scene, plainCamera);

        if (
          !enablePathTracing ||
          kaleidoControls.state === 0 ||
          plainControls.state === 0
        ) {
          kaleidoRenderer.render(scene, kaleidoCamera);
        } else {
          if (sampleCount <= samples) {
            try {
              pathTracer.renderSample();
              renderSampleCount(sampleCount, samples);
              incrementSampleCount();
            } catch (e) {
              console.log("renderSample error", e);
              throw e;
            }
          }
        }

      } while (true);
    })();
  </script>
  <script id="105" type="text/x-typescript" pinned="">
    void samples;
    void enablePathTracing;

    const sampleCount = Mutable(0);

    const resetSampleCount = () => sampleCount.value = 0;
    const incrementSampleCount = () => sampleCount.value += 1;

    const samplesOverlay = container.querySelector("#samples-overlay");
    const renderSampleCount = (count, total) => samplesOverlay.innerText = `${count}/${total}`;

    invalidation.then(() => resetSampleCount());
  </script>
  <script id="183" type="text/x-typescript" pinned="">
    function resetRender() {
      resetSampleCount();
      pathTracer.reset();
    }

  </script>
  <script id="130" type="text/x-typescript" pinned="">
    const PLAIN_LAYER = 3;
    const KALEIDO_LAYER = 4;
  </script>
  <script id="3" type="text/x-typescript" pinned="">
    const SHAPE_MAP = {
      Box: THREE.BoxGeometry,
      Cylinder: THREE.CylinderGeometry,
      Sphere: THREE.SphereGeometry,
      Torus: THREE.TorusGeometry,
      TorusKnot: THREE.TorusKnotGeometry,
      Icosahedron: THREE.IcosahedronGeometry,
      Tetrahedron: THREE.TetrahedronGeometry,
      Octahedron: THREE.OctahedronGeometry,
    };

    type ShapeType = keyof SHAPE_MAP;

    const shapeColors = d3.scaleOrdinal(Object.keys(SHAPE_MAP), d3.schemeObservable10);
  </script>
  <script id="64" type="text/x-typescript" pinned="">
    const MATERIAL_MAP = {
      Normal: THREE.ShaderMaterial,
      Lambert: THREE.MeshLambertMaterial,
      Phong: THREE.MeshPhongMaterial,
    };

    type MaterialType = keyof SHAPE_MAP;
  </script>
  <script id="18" type="text/markdown">
    ### TODO

    - [ ] “variation scale” option
    - [ ] random distribution options
  </script>
  <script id="58" type="text/markdown">
    ## Config setup

    ${nav("config-setup")}
  </script>
  <script id="11" type="text/x-typescript">
    interface ShapesConfig {
      count: number;
      boundary: number;
      size: {
        min: number;
        max: number;
      },
      types: ShapeType[],
    }

    const count = input(Inputs.range([1, 64], {step: 1, label: "Count", value: 20}));
    const boundary = input(Inputs.range([1, 64], {step: 1, label: "Boundary", value: 10}));
    const size = input(interval([1, 16], {step: 1, label: "Size", value: [1, 3]}));
    const types = input(Inputs.checkbox(Object.keys(SHAPE_MAP), {label: "Shape types", value: Object.keys(SHAPE_MAP).filter(v => v !== "TorusKnot")}));

    const shapesForm = [
      html`<h4>Shapes`,
      ...[count, boundary, size, types].map(i => i.element),
    ];
  </script>
  <script id="69" type="text/x-typescript" pinned="">
    interface MaterialConfig {
      wireframe: "none" | "some" | "all";
      materialType: MaterialType;
      materialColor: ColorScheme;
    }

    const wireframe = input(Inputs.radio(["none", "some", "all"], {label: "Wireframe", value: "none"}));
    const materialType = input(Inputs.select(Object.keys(MATERIAL_MAP), {label: "Material", value: "Normal"}));
    const materialColor = input(Inputs.select(schemeKeys, {label: "Color", value: "schemeSpectral"}));

    const materialForm = [
      html`<h4>Material`,
      wireframe.element,
      materialType.element,
      materialColor.element
    ]
  </script>
  <script id="56" type="text/x-typescript">
    interface KaleidoConfig {
      sides: number;
      length: number;
      roughness: number;
      metalness: number;
    }

    const sides = input(Inputs.range([3, 4], {step: 1, label: "Number (sides)", value: 3}));
    const length = input(Inputs.range([1, 50], {step: 1, label: "Length", value: 6}));
    const roughness = input(Inputs.range([0, 1], {step: 0.01, label: "Roughness", value: 0.03}));
    const metalness = input(Inputs.range([0, 1], {step: 0.01, label: "Metalness", value: 1}));
    const rotation = input(Inputs.range([0, 180], {step: 1, label: "Rotation (deg)", value: 0}))

    const kaleidoForm = [
        html`<h4>Mirrors`,
        ...[sides, length, roughness, metalness, rotation].map(i => i.element),
    ];
  </script>
  <script id="57" type="text/x-typescript">
    interface RenderConfig {
      enablePathTracing: boolean;
      background: string;
      bounces: number;
      samples: number;
    }

    const enablePathTracing = input(Inputs.toggle({label: "Enable path tracing", value: false}));
    const dynamicLowRes = input(Inputs.toggle({label: "Dynamic low resolution", value: true}))
    const bounces = input(Inputs.range([1, 60], {step: 1, label: "Light bounces", value: 6}));
    const samples = input(Inputs.range([1, 1000], {step: 1, label: "Render samples", value: 100}));
    const background = input(Inputs.color({label: "Background color", value: "#EEEEEE"})); // #171720

    const renderingForm = [
        html`<h4>Rendering`,
      ...[enablePathTracing, dynamicLowRes, bounces, samples, background].map(i => i.element)
    ];
  </script>
  <script id="179" type="text/x-typescript" pinned="">
    const refreshShapes = input(Inputs.button("Generate shapes", {value: null, reduce: () => Date.now()}));
    const refreshShapesButton = refreshShapes.element;
  </script>
  <script id="51" type="text/x-typescript" hidden="">
    const useShapeDistribution = input(Inputs.toggle({label: "Control shape distribution", value: true}));
    const useShapeDistributionToggle = useShapeDistribution.element;
  </script>
  <script id="42" type="text/x-typescript">
    const initialTypes = types.map(s => ({label: s, value: 100 / types.length}));
    const shapeDistribution = input(inputTemplate(
      categoricalSlider(initialTypes, {scope: "shapeDistribution", disabled: !useShapeDistribution}),
      {label: "Shape distribution", width: "100%", wrap: false}
    ));

    const shapeDistributionInput = [
      shapeDistribution.element,
      html`<style>
        .shapeDistribution {
          line-height: 1.5;
          margin-right: var(--length2);
        }
      </style>`
    ];
  </script>
  <script id="70" type="text/x-typescript" pinned="">
    const advancedForm = details({label: "Advanced"});
  </script>
  <script id="85" type="text/x-typescript" pinned="">
    const resetCameras = input(Inputs.button("Reset cameras", {value: null, reduce: () => Date.now()}));
    const lockKaleidoAngle = input(Inputs.toggle({label: "Lock kaleidoscope angle", value: true}));
    const useCylinderMirror = input(Inputs.toggle({label: "Use cylinder-based mirror", value: false}))

    advancedForm.contents = html.fragment`
      ${resetCameras.element}
      ${lockKaleidoAngle.element}
      <hr style="padding: 0.25rem 0; margin: 0;">
      ${useCylinderMirror.element}
      <hr style="padding: 0.25rem 0; margin: 0;">
      ${useShapeDistributionToggle}
      ${shapeDistributionInput}
    `;
  </script>
  <script id="22" type="text/markdown">
    ---

    ## Appendix

    ${nav("appendix")}
  </script>
  <script id="2" type="text/x-typescript" pinned="">
    import * as THREE from "npm:three@0.170.0";
    import { OrbitControls } from "npm:three@0.170.0/addons/controls/OrbitControls";
    import { EffectComposer } from "npm:three@0.170.0/addons/postprocessing/EffectComposer";
    import { RenderPass } from "npm:three@0.170.0/examples/jsm/postprocessing/RenderPass";
    import { ShaderPass } from "npm:three@0.170.0/examples/jsm/postprocessing/ShaderPass";
    import { OutputPass } from "npm:three@0.170.0/examples/jsm/postprocessing/OutputPass";
    import { KaleidoShader } from "npm:three@0.170.0/examples/jsm/shaders/KaleidoShader";
  </script>
  <script id="164" type="text/x-typescript" pinned="">
    import { RectAreaLightUniformsLib } from "npm:three@0.170.0/addons/lights/RectAreaLightUniformsLib"
  </script>
  <script id="157" type="text/x-typescript" pinned="">
    import { RectAreaLightHelper } from "npm:three@0.170.0/addons/helpers/RectAreaLightHelper"
  </script>
  <script id="102" type="text/x-typescript" pinned="">
    import { WebGLPathTracer, GradientEquirectTexture } from "https://esm.sh/gh/gkjohnson/three-gpu-pathtracer";
  </script>
  <script id="120" type="text/x-typescript" pinned="">
    // https://github.com/gkjohnson/three-mesh-bvh/blob/master/src/workers/GenerateMeshBVHWorker.js
    // loads bundled worker from esm.sh and removes references to SharedArrayBuffer

    import { MeshBVH } from "npm:three-mesh-bvh";
    import { WorkerBase } from "npm:three-mesh-bvh/src/workers/utils/WorkerBase";
    import createBVHWorker from "https://esm.sh/three-mesh-bvh/src/workers/generateMeshBVH.worker.js?deps=three@0.170.0&worker";

    class GenerateMeshBVHWorker extends WorkerBase {
      constructor() {
        const worker = createBVHWorker();
        super(worker);
        this.name = "GenerateMeshBVHWorker";
      }

      runTask(worker, geometry, options = {}) {
        return new Promise((resolve, reject) => {
          if (
            geometry.getAttribute("position").isInterleavedBufferAttribute ||
            (geometry.index && geometry.index.isInterleavedBufferAttribute)
          ) {
            throw new Error(
              "GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes."
            );
          }

          worker.onerror = (e) => {
            reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));
          };

          worker.onmessage = (e) => {
            const {data} = e;

            if (data.error) {
              reject(new Error(data.error));
              worker.onmessage = null;
            } else if (data.serialized) {
              const { serialized, position } = data;
              const bvh = MeshBVH.deserialize(serialized, geometry, {setIndex: false});
              const boundsOptions = Object.assign(
                {setBoundingBox: true},
                options
              );

              // we need to replace the arrays because they're neutered entirely by the
              // webworker transfer.
              geometry.attributes.position.array = position;
              if (serialized.index) {
                if (geometry.index) {
                  geometry.index.array = serialized.index;
                } else {
                  const newIndex = new THREE.BufferAttribute(serialized.index, 1, false);
                  geometry.setIndex(newIndex);
                }
              }

              if (boundsOptions.setBoundingBox) {
                geometry.boundingBox = bvh.getBoundingBox(new THREE.Box3());
              }

              if (options.onProgress) {
                options.onProgress(data.progress);
              }

              resolve(bvh);
              worker.onmessage = null;
            } else if (options.onProgress) {
              options.onProgress(data.progress);
            }
          };

          const index = geometry.index ? geometry.index.array : null;
          const position = geometry.attributes.position.array;
          const transferable = [position];
          if (index) {
            transferable.push(index);
          }

          worker.postMessage(
            {
              index,
              position,
              options: {
                ...options,
                onProgress: null,
                includedProgressCallback: Boolean(options.onProgress),
                groups: [...geometry.groups],
              },
            },
            transferable.map((arr) => arr.buffer)
          );
        });
      }
    }
  </script>
  <script id="12" type="text/x-typescript" pinned="">
    import { interval } from "observable:@mootari/range-slider";
    import { inputTemplate } from "observable:@cubeghost/input-template-desktop";
    import { categoricalSlider } from "observable:@cubeghost/window-splitter-slider";
    import { conditionalShow } from "observable:@john-guerra/conditional-show"
  </script>
  <script id="63" type="text/x-typescript" pinned="">
    import * as schemes from "npm:d3-scale-chromatic";

    const schemeKeys = Object.keys(schemes).filter(k => k.startsWith("scheme"));
    const interpolateKeys = Object.keys(schemes).filter(k => k.startsWith("interpolate"));

    type ColorScheme = (typeof schemeKeys)[number];

    function getScaleForScheme(schemeKey: typeof schemeKeys) {
      const interpolateKey = schemeKey.replace("scheme", "interpolate");
      if (interpolateKeys.includes(interpolateKey)) {
        return d3.scaleSequential(d3[interpolateKey]);
      } else {
        return d3.scaleOrdinal(d3[schemeKey]);
      }
    }
  </script>
  <script id="82" type="text/x-typescript" pinned="">
    const PAGE_SECTIONS = {
      "top": "Config",
      "scene-generation": {
        label: "Scene generation",
        children: {
          "scene-generation--shapes": "Shapes",
          "scene-generation--mirrors": "Mirrors",
          "scene-generation--lights": "Lights"
        }
      },
      "rendering-setup": {
        label: "Rendering setup",
        children: {
          "rendering-setup--cameras": "Cameras",
          "rendering-setup--renderers": "Renderers",
          "rendering-setup--controls": "Controls",
          "rendering-setup--render-loop": "Render loop",
        }
      },
      "config-setup": "Config setup",
      "appendix": "Appendix"
    };

    function nav(current: keyof PAGE_SECTIONS) {
      const link = ([id, label], i) => htl.html.fragment`${i ? "•" : ""}<a href=${id === current ? null : `#${id}`}>${label}`;

      return htl.html`<div style="
        font: 13px/1.5 var(--sans-serif);
        display: flex;
        gap: 1ch;
        padding-bottom: 0.5rem;
      ">${
        Object.entries(PAGE_SECTIONS).flatMap((entry, i) => {
          if (typeof entry[1] === "string") {
            return link(entry, i);
          } else {
            const [id, { label, children }] = entry;
            const childIds = Object.keys(children);
            if (id === current || childIds.includes(current)) {
              return [htl.html.fragment`${i ? "•" : ""}<span>[`, ...Object.entries(children).map(link), htl.html`<span>]`]
            } else {
              return link([id, label], i);
            }
          }
        })
      }`
    }
  </script>
  <script id="75" type="text/x-typescript" pinned="">
    // creates a `<details>` element that can stay open even as contents change
    // contents must be set on the `.contents` property
    function details({label, defaultOpen} = {}) {
      let open = Mutable(defaultOpen ?? false);

      const element = htl.html`<details ${open.value ? {open: true} : {}}>
        <summary>${label}</summary>
      </details>`;

      element.addEventListener("toggle", (event) => {
        open.value = element.open;
      });

      return Object.defineProperty(
        element,
        "contents",
        {
          get: () => element.querySelectorAll("&>*:not(summary)"),
          set: (contents) => {
            element.querySelectorAll("&>*:not(summary)").forEach(n => element.removeChild(n));
            element.appendChild(contents);
            element.open = open.value;
          }
        }
      );
    }
  </script>
  <script id="21" type="text/x-typescript" pinned="">
    // https://github.com/observablehq/notebook-kit/discussions/32
    function input(element) {
      const generator = Generators.input(element);
      generator.element = element;
      return generator;
    }

    // cannot figure out how to make a generator out of Inputs.form
  </script>
</notebook>
