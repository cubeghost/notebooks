<!doctype html>
<notebook theme="air">
  <title>three.js kaleidoscope playground</title>
  <script id="1" type="text/markdown">
    # three.js kaleidoscope playground
    <div id="top" />
    ${nav("top")}
  </script>
  <script id="49" type="text/html">
    <div style="display: flex; max-width: 100%;" id="form">
      <div>
        ${shapesForm}
        ${materialForm}
      </div>
      <div>
        ${kaleidoForm}
        <br />
        ${renderingForm}
      </div>
    </div>
    <div>
      ${advancedForm}
    </div>
  </script>
  <script id="6" type="text/x-typescript">
    const container = display(html`
    <div>
      <div style="display: flex;" id="controls">
        <canvas id="camera"></canvas>
        <canvas id="kaleido" style="transform: translateX(-1px);"></canvas>
      </div>
      <small>Drag to rotate, scroll to zoom, right click to pan</small>
    </div>`);
  </script>
  <script id="89" type="text/markdown">
    ### Scene generation
  </script>
  <script id="17" type="text/x-typescript">
    interface Shape {
      geometry: {
        Class: typeof SHAPE_MAP[keyof SHAPE_MAP];
        args: number[];
      };
      positon: [number, number, number];
      rotation: [number, number, number];
      wireframe: boolean;
      color: string;
    }

    function generateShapes(config: ShapeConfig): Shape[] {
      const size = d3.randomInt(config.size[0], config.size[1]);
      const positionScale = d3.randomInt(-config.boundary / 2, config.boundary / 2);
      const rotationScale = d3.randomInt(0, Math.PI * 2);
      const geometryScale = d3.scaleQuantize(config.types);
      const colorScale = getScaleForScheme(config.color);
      const wireframeScale = d3.scaleQuantize([true, false]);
      const random = d3.randomUniform();

      const shapeArray: (keyof SHAPE_MAP) = useShapeDistribution
        ? d3.shuffle(shapeDistribution.flatMap((d) => Array.from({length: config.count * (d.value / 100)}, () => d.label)))
        : Array.from({length: config.count}, () => geometryScale(random()));

      return shapeArray.map((shapeName) => {
        const wireframe = config.wireframe === "all" ? true :
                          config.wireframe === "none" ? false :
                          wireframeScale(random());
        const color = colorScale(random());

        const geometryClass = SHAPE_MAP[shapeName];
        const geometryArgs = (() => {
          switch (geometryClass) {
            case THREE.BoxGeometry:
              return [size(), size(), size()];
            case THREE.CylinderGeometry:
              const end = size();
              return [end, end, size()];
            case THREE.SphereGeometry: {
              const diameter = size();
              if (wireframe) {
                // variation on segment count
                const segments = d3.max([8, d3.min([diameter * 4, 20])]);
                const v = d3.randomLogNormal(0, diameter / 3);
                return [diameter, segments - v(), segments - v()];
              } else {
                return [diameter, 20, 20];
              }
            }
            case THREE.TorusGeometry: {
              const diameter = size();
              const hole = d3.randomUniform(0.2, 0.8);
              if (wireframe) {
                // variation on segment count
                const segments = d3.max([8, d3.min([diameter * 4, 20])]);
                const v = d3.randomLogNormal(0, diameter / 3);
                return [diameter, diameter * hole(), segments - v(), (segments - v()) * 4];
              } else {
                return [diameter, diameter * hole(), 20, 80];
              }
            }
            case THREE.IcosahedronGeometry:
            case THREE.TetrahedronGeometry:
            case THREE.OctahedronGeometry:
              return [size(), 0];
            default:
              return [];
          }
        })();

        const position = Array.from({length: 3}, positionScale);
        const rotation = Array.from({length: 3}, rotationScale);

        return {
          geometry: {
            Class: geometryClass,
            args: geometryArgs,
          },
          position,
          rotation,
          wireframe,
          color,
        };
      });
    };
  </script>
  <script id="67" type="text/x-typescript" pinned="">
    refresh;

    const shapes = generateShapes({count, boundary, size, types, wireframe, color: materialColor});
  </script>
  <script id="66" type="text/x-typescript" pinned="">
    const MaterialClass = MATERIAL_MAP[material];

    function getMaterialArgs(shape: Shape) {
      const {wireframe, color} = shape;
      switch (MaterialClass) {
        case THREE.MeshPhongMaterial:
          return {wireframe, color, emissive: 0x000000, specular: background, shininess: 500};
        case THREE.MeshLambertMaterial:
          return {wireframe, color};
        case THREE.MeshNormalMaterial:
        default:
          return {wireframe};
      }
    }
  </script>
  <script id="13" type="text/x-typescript" pinned="">
    const shapeGroup = new THREE.Group();
    shapeGroup.name = "ShapeGroup";

    for (const shape of shapes) {
      const geometry = new shape.geometry.Class(...shape.geometry.args);
      const shapeMaterial = new MaterialClass(getMaterialArgs(shape));
      const mesh = new THREE.Mesh(geometry, shapeMaterial);
      mesh.position.fromArray(shape.position);
      mesh.rotation.fromArray(shape.rotation);
      shapeGroup.add(mesh);
    }

    scene.add(shapeGroup);

    invalidation.then(() => {
      shapeGroup.removeFromParent();
      shapeGroup.clear();
    });
  </script>
  <script id="90" type="text/markdown">
    ### Rendering setup
  </script>
  <script id="9" type="text/x-typescript" pinned="">
    refresh;

    const scene = new THREE.Scene();

    invalidation.then(() => scene.clear());
  </script>
  <script id="27" type="text/x-typescript" pinned="">
    scene.background = new THREE.Color(background);
  </script>
  <script id="62" type="text/x-typescript" pinned="">
    const hemisphereLight = new THREE.HemisphereLight(0xFFFFFF, background, 5);
    scene.add(hemisphereLight);

    invalidation.then(() => {
      hemisphereLight.removeFromParent();
      hemisphereLight.dispose();
    });
  </script>
  <script id="68" type="text/x-typescript" pinned="">
    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.75);
    directionalLight.position.set(0, 0, 20);
    camera.add(directionalLight);

    invalidation.then(() => {
      directionalLight.removeFromParent();
      directionalLight.dispose();
    });
  </script>
  <script id="8" type="text/x-typescript" pinned="">
    const fov = 45, aspect = 1, near = 1, far = 1000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.set(0, 0, 20);
    scene.add(camera);
  </script>
  <script id="4" type="text/x-typescript">
    // side-by-side renderers
    const cameraRenderer = new THREE.WebGLRenderer({canvas: cameraCanvas, preserveDrawingBuffer: true, antialias: true});
    const kaleidoRenderer = new THREE.WebGLRenderer({canvas: kaleidoCanvas, preserveDrawingBuffer: true, antialias: true});

    const renderers = [cameraRenderer, kaleidoRenderer];

    const canvasSize = Math.floor(width / 2);
    for (const renderer of renderers) {
      renderer.setSize(canvasSize, canvasSize);
      renderer.setPixelRatio(devicePixelRatio);
    }

    // apply KaleidoShader
    const composer = new EffectComposer(kaleidoRenderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const shaderPass = new ShaderPass(KaleidoShader);
    shaderPass.uniforms['sides'].value = sides;
    shaderPass.uniforms['angle'].value = angle * Math.PI / 180;
    composer.addPass(shaderPass);
    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    invalidation.then(() => {
      renderers.forEach(r => r.dispose());
    });
  </script>
  <script id="88" type="text/x-typescript" pinned="">
    const controls = new OrbitControls(camera, controlElement);
    controls.enableDamping = true;
    controls.addEventListener("change", () => renderers.forEach(r => r.render(scene, camera)));

    invalidation.then(() => {
      controls.dispose();
    });
  </script>
  <script id="95" type="text/x-typescript" pinned="">
    controls.autoRotate = autoRotate;
  </script>
  <script id="87" type="text/x-typescript" pinned="">
    // render loop
    const tick = (async function* () {
      do {
        yield null;
        controls.update();
        cameraRenderer.render(scene, camera);
        composer.render();
      } while (true);
    })();
  </script>
  <script id="5" type="text/x-typescript" pinned="">
    const controlElement = container.querySelector("#controls");
    const cameraCanvas = container.querySelector("#camera");
    const kaleidoCanvas = container.querySelector("#kaleido");
  </script>
  <script id="3" type="text/x-typescript" pinned="">
    const SHAPE_MAP = {
      Box: THREE.BoxGeometry,
      Cylinder: THREE.CylinderGeometry,
      Sphere: THREE.SphereGeometry,
      Torus: THREE.TorusGeometry,
      Icosahedron: THREE.IcosahedronGeometry,
      Tetrahedron: THREE.TetrahedronGeometry,
      Octahedron: THREE.OctahedronGeometry,
    };

    type ShapeType = keyof SHAPE_MAP;

    const shapeColors = d3.scaleOrdinal(Object.keys(SHAPE_MAP), d3.schemeObservable10);
  </script>
  <script id="64" type="text/x-typescript" pinned="">
    const MATERIAL_MAP = {
      Normal: THREE.MeshNormalMaterial,
      Lambert: THREE.MeshLambertMaterial,
      Phong: THREE.MeshPhongMaterial,
    };

    type MaterialType = keyof SHAPE_MAP;
  </script>
  <script id="18" type="text/markdown">
    ### TODO
    - [ ] “variation scale” option
    - [ ] random distribution options
  </script>
  <script id="58" type="text/markdown">
    ## Config setup
    ${nav("config-setup")}
  </script>
  <script id="11" type="text/x-typescript">
    interface ShapesConfig {
      count: number;
      boundary: number;
      size: {
        min: number;
        max: number;
      },
      types: ShapeType[],
    }

    const count = input(Inputs.range([1, 64], {step: 1, label: "Count", value: 20}));
    const boundary = input(Inputs.range([1, 64], {step: 1, label: "Boundary", value: 10}));
    const size = input(interval([1, 16], {step: 1, label: "Size", value: [1, 3]}));
    const types = input(Inputs.checkbox(Object.keys(SHAPE_MAP), {label: "Shape types", value: Object.keys(SHAPE_MAP)}));

    const shapesForm = [
      html`<h4>Shapes`,
      ...[count, boundary, size, types].map(i => i.element),
    ];
  </script>
  <script id="69" type="text/x-typescript" pinned="">
    interface MaterialConfig {
      wireframe: "none" | "some" | "all";
      material: MaterialType;
      materialColor: ColorScheme;
    }

    const wireframe = input(Inputs.radio(["none", "some", "all"], {label: "Wireframe", value: "none"}));
    const material = input(Inputs.select(Object.keys(MATERIAL_MAP), {label: "Material", value: "Normal"}));
    const materialColor = input(Inputs.select(schemeKeys, {label: "Color", value: "schemeSpectral"}));

    const materialForm = [
      html`<h4>Material`,
      wireframe.element,
    ]
  </script>
  <script id="56" type="text/x-typescript">
    interface KaleidoConfig {
      sides: number;
      angle: number;
    }

    const sides = input(Inputs.range([1, 24], {step: 1, label: "Sides", value: 6}));
    const angle = input(Inputs.range([0, 180], {step: 1, label: "Angle", value: 45}));

    const kaleidoForm = [
        html`<h4>Kaleidoscope`,
        ...[sides, angle].map(i => i.element),
    ];
  </script>
  <script id="57" type="text/x-typescript">
    interface RenderConfig {
      background: string;
      autoRotate: boolean;
    }

    const background = input(Inputs.color({label: "Background color", value: "#171720"}));
    const autoRotate = input(Inputs.toggle({label: "Auto-rotate", value: false}));

    const renderingForm = [
        html`<h4>Rendering`,
      ...[background, autoRotate].map(i => i.element)
    ];
  </script>
  <script id="51" type="text/x-typescript" hidden="">
    const useShapeDistribution = input(Inputs.toggle({label: "Control shape distribution?", value: true}));
    const useShapeDistributionToggle = useShapeDistribution.element;
  </script>
  <script id="42" type="text/x-typescript">
    const initialTypes = types.map(s => ({label: s, value: 100 / types.length}));
    const shapeDistribution = input(inputTemplate(
      categoricalSlider(initialTypes, {scope: "shapeDistribution", disabled: !useShapeDistribution}),
      {label: "Shape distribution", width: "100%", wrap: false}
    ));

    const shapeDistributionInput = [
      shapeDistribution.element,
      html`<style>
        .shapeDistribution {
          line-height: 1.5;
          margin-right: var(--length2);
        }
      </style>`
    ];
  </script>
  <script id="70" type="text/x-typescript" pinned="">
    const advancedForm = details({label: "Advanced"});
  </script>
  <script id="85" type="text/x-typescript" pinned="">
    advancedForm.contents = html.fragment`
      ${useShapeDistributionToggle}
      ${shapeDistributionInput}
    `;
  </script>
  <script id="22" type="text/markdown">
    ---
    ${nav("appendix")}
    ## Appendix
  </script>
  <script id="2" type="text/x-typescript" pinned="">
    import * as THREE from "npm:three";
    import { OrbitControls } from "npm:three/addons/controls/OrbitControls";
    import { EffectComposer } from 'npm:three/addons/postprocessing/EffectComposer';
    import { RenderPass } from 'npm:three/examples/jsm/postprocessing/RenderPass';
    import { ShaderPass } from 'npm:three/examples/jsm/postprocessing/ShaderPass';
    import { OutputPass } from 'npm:three/examples/jsm/postprocessing/OutputPass';
    import { KaleidoShader } from 'npm:three/examples/jsm/shaders/KaleidoShader';
  </script>
  <script id="12" type="text/x-typescript" pinned="">
    import { interval } from "observable:@mootari/range-slider";
    // import { inputTemplate } from "observable:@mootari/input-template"; // see below
    import { categoricalSlider } from "observable:@cubeghost/window-splitter-slider";
    import { conditionalShow } from "observable:@john-guerra/conditional-show"
  </script>
  <script id="63" type="text/x-typescript" pinned="">
    import * as schemes from "npm:d3-scale-chromatic";

    const schemeKeys = Object.keys(schemes).filter(k => k.startsWith("scheme"));
    const interpolateKeys = Object.keys(schemes).filter(k => k.startsWith("interpolate"));

    type ColorScheme = (typeof schemeKeys)[number];

    function getScaleForScheme(schemeKey: typeof schemeKeys) {
      const interpolateKey = schemeKey.replace("scheme", "interpolate");
      if (interpolateKeys.includes(interpolateKey)) {
        return d3.scaleSequential(d3[interpolateKey]);
      } else {
        return d3.scaleOrdinal(d3[schemeKey]);
      }
    }
  </script>
  <script id="82" type="text/x-typescript" pinned="">
    const PAGE_SECTIONS = {
      "top": "Config",
      "scene-generation": "Scene generation",
      "rendering-setup": "Rendering setup",
      "config-setup": "Config setup",
      "appendix": "Appendix"
    };

    function nav(current: keyof PAGE_SECTIONS) {
      return htl.html`<div style="
        font: 13px/1.5 var(--sans-serif);
        display: flex;
        gap: 1ch;
        padding-bottom: 0.5rem;
      ">${
        Object.entries(PAGE_SECTIONS).map(
          ([id, label], i) => htl.html.fragment`${i ? "•" : ""}<a href=${id === current ? null : `#${id}`}>${label}`
        )
      }`
    }
  </script>
  <script id="75" type="text/x-typescript" pinned="">
    // creates a `<details>` element that can stay open even as contents change
    // contents must be set on the `.contents` property
    function details({label, defaultOpen} = {}) {
      let open = Mutable(defaultOpen ?? false);

      const element = htl.html`<details ${open.value ? {open: true} : {}}>
        <summary>${label}</summary>
      </details>`;

      element.addEventListener("toggle", (event) => {
        open.value = element.open;
      });

      return Object.defineProperty(
        element,
        "contents",
        {
          get: () => element.querySelectorAll("&>*:not(summary)"),
          set: (contents) => {
            element.querySelectorAll("&>*:not(summary)").forEach(n => element.removeChild(n));
            element.appendChild(contents);
            element.open = open.value;
          }
        }
      );
    }
  </script>
  <script id="30" type="text/x-typescript" pinned="">
    const refresh = input(Inputs.button("Generate", {value: null, reduce: () => Date.now()}));

    display(html`<div class="refresh-button">${refresh.element}</div>`);
  </script>
  <script id="31" type="text/html" pinned="">
    <style>
      .refresh-button {
        position: absolute; top: 3rem; left: ${width}px; transform: translateX(-50%)
      }
      .refresh-button form {
        width: unset !important;
      }
    </style>
  </script>
  <script id="21" type="text/x-typescript" pinned="">
    // https://github.com/observablehq/notebook-kit/discussions/32
    function input(element) {
      const generator = Generators.input(element);
      generator.element = element;
      return generator;
    }

    // cannot figure out how to make a generator out of Inputs.form
  </script>
  <script id="41" type="text/x-typescript" pinned="">
    // hack to get @mootari/input-template to work
    const inputTemplate = (async () => {
      const ns = Inputs.text().classList[0];
      if (!document.querySelector(`head style.${ns}`)) {
        const res = await fetch("https://cdn.jsdelivr.net/npm/@observablehq/inputs/dist/index.css");
        const stylesheet = await res.text();
        const styleElement = document.createElement("style");
        styleElement.innerText = stylesheet;
        styleElement.classList.add(ns);
        document.querySelector("head").appendChild(styleElement);
      }

      const {inputTemplate: fn} = await asyncImportObservable(["inputTemplate"], "@mootari/input-template");
      return fn;
    })();
  </script>
  <script id="44" type="text/x-typescript" pinned="">
    // async import of an `observable:` import
    // https://github.com/observablehq/notebook-kit/blob/main/src/javascript/imports/observable.ts#L22
    async function asyncImportObservable(specifiers: string[], pkg: string) {
      const _ = await import(`https://api.observablehq.com/${pkg}.js?v=4`);
      const observers = {};
      const module = __ojs_runtime.module(_.default);
      const main = __ojs_runtime.module();
      for (const spec of specifiers) {
        // ignoring the dollar stuff for now
        if (!module.defines(spec)) throw new SyntaxError(`export '${spec}' not found`);
        main.variable(observers[spec] = __ojs_observer()).import(spec, module);
      }
      return observers;
    }
  </script>
  <script id="94" type="text/x-typescript" pinned="">
    // attempt at auto-rotate with TrackballControls (to get around polar limitation of OrbitControls)

    // const controls = new TrackballControls(camera, controlElement);
    // controls.rotateSpeed = 1.5;
    // controls.screen.width = width / 2; // adjust rotation amount relative to width of each canvas

    // let shapeAngle = 0;
    // const shapeQuaternion = new THREE.Quaternion();

    // if (autoRotate && controls.state === -1) {
    //   // const deg = THREE.MathUtils.radToDeg(controls._lastAngle);
    //   // const _angle = THREE.MathUtils.degToRad(deg + 0.05);
    //   // quaternion.setFromAxisAngle(controls._lastAxis, _angle);
    //   // controls.object.up.applyQuaternion(quaternion);
    //   // controls._eye.applyQuaternion(quaternion);
    //   // controls._lastAngle = _angle;
    //   shapeAngle = (shapeAngle + 0.01) % (Math.PI * 2);
    //   shapeQuaternion.setFromAxisAngle(controls._lastAxis, shapeAngle);
    //   shapeGroup.rotation.setFromQuaternion(shapeQuaternion);
    //   // shapeGroup.rotation.x = rotX;
    //   // shapeGroup.rotation.y = rotY;
    //   // rotX += 0.01;
    //   // rotY += 0.01 / 2;
    // }

  </script>
</notebook>
